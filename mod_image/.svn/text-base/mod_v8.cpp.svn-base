/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"

#include "v8.h"

using namespace v8;

static apr_status_t read_whole_file(const char *path,
                                    const char **out,
                                    apr_size_t *outlen,
                                    apr_pool_t *long_pool,
                                    apr_pool_t *temp_pool)
{
    char *c;
    apr_size_t len = 0;
    apr_status_t rv;
    apr_file_t *fp;
    apr_finfo_t fi;

    *out = NULL;
    *outlen = 0;

    rv = apr_file_open(&fp, path, APR_READ|APR_BINARY|APR_BUFFERED,
                       APR_OS_DEFAULT, temp_pool);

    if (rv) {
        return rv;
    }

    rv = apr_file_info_get(&fi, APR_FINFO_SIZE, fp);
    
    if (rv) {
        return rv;
    }

    apr_bucket_alloc_t *ba = apr_bucket_alloc_create(temp_pool);
    apr_bucket_brigade *bb = apr_brigade_create(temp_pool, ba);

    apr_brigade_insert_file(bb, fp, 0, fi.size, temp_pool);

    rv = apr_brigade_pflatten(bb, &c, &len, long_pool);
    
    if (rv) {
        return rv;
    }

    *out = c;
    *outlen = len;
    
    return APR_SUCCESS;
}

static Handle<Value> LogCallback(const Arguments& args) {
    if (args.Length() < 1) return v8::Undefined();
    HandleScope scope;
    Handle<Value> arg = args[0];
    String::Utf8Value value(arg);
    Local<Object> self = args.Holder();
    Local<External> wrap = Local<External>::Cast(self->GetInternalField(0));

    request_rec *r = static_cast<request_rec*>(wrap->Value());

    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "v8::log: %s", *value);

    return v8::Undefined();
}

static Handle<Value> WriteCallback(const Arguments& args) {
    if (args.Length() < 1) return v8::Undefined();
    HandleScope scope;
    Handle<Value> arg = args[0];
    String::Utf8Value value(arg);
    Local<Object> self = args.Holder();
    Local<External> wrap = Local<External>::Cast(self->GetInternalField(0));

    request_rec *r = static_cast<request_rec*>(wrap->Value());

    ap_rputs(*value, r);

    return v8::Undefined();
}

static int v8_handler(request_rec *r)
{
    apr_status_t rv;
    int rc = OK;

    if (strcmp(r->handler, "v8-script") != 0) {
        return DECLINED;
    }

    {
        // Create a stack-allocated handle scope.
        HandleScope handle_scope;
 
        Handle<ObjectTemplate> global = ObjectTemplate::New();
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "object tempalte");

        global->SetInternalFieldCount(1);
        global->Set(String::New("log"), FunctionTemplate::New(LogCallback));
        global->Set(String::New("write"), FunctionTemplate::New(WriteCallback));

        // Create a new context.
        Persistent<Context> context = Context::New();
        
        // Enter the created context for compiling and
        // running the hello world script.&nbsp;
        Context::Scope context_scope(context);
        
        Handle<Object> obj = global->NewInstance();
        obj->SetInternalField(0, External::New(r));
        context->Global()->Set(String::New("ap"), obj);
        
        // Create a string containing the JavaScript source code.
        const char *src;
        apr_size_t len;
        apr_pool_t *tpool;
        apr_pool_create(&tpool, r->pool);

        rv = read_whole_file(r->filename, &src, &len, r->pool, tpool);
        
        apr_pool_clear(tpool);

        if (rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "v8: Failed to read: %s", r->filename);
            return HTTP_INTERNAL_SERVER_ERROR;
        }

        Handle<String> source = String::New(src, len);

        {
            TryCatch try_catch;

            // Compile the source code.
            Handle<Script> script = Script::Compile(source);
            // Run the script to get the result.
            Handle<Value> result = script->Run();

            if (result.IsEmpty()) {
                // The TryCatch above is still in effect and will have caught the error.
                String::AsciiValue error(try_catch.Exception());
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                            "v8: Script(%s) Failed: %s", r->filename, *error);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            
            if (!result->IsInt32()) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                              "v8: Script must return an int32 value.");
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            
            rc = result->Int32Value();
        }
        // Dispose the persistent context.
        context.Dispose();
    }

    return rc;
}

static const command_rec cmds[] = {
    {NULL}
};

static void register_hooks(apr_pool_t *p)
{
    ap_hook_handler(v8_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

extern "C" {

    module AP_MODULE_DECLARE_DATA v8_module = {
        STANDARD20_MODULE_STUFF,
        NULL,               /* dir config creater */
        NULL,               /* dir merger --- default is to override */
        NULL,               /* server config */
        NULL,               /* merge server config */
        cmds,               /* commands */
        register_hooks
    };

}; /* end extern C */


